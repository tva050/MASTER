""" 
This script includes an comprehensive comparison of the different products used to estimate sea ice thickness.
The comparison is done by plotting the data on a map and comparing the results visually.

The script includes the products:
- CryoSat-2 L2 Trajectory Data Baseline D
- CS2 ice thickness data from AWI
- CS2 ice thickness data from CPOM
- SMOS ice thickness data
- CryoSat-2 L3 

"""
import os
import numpy as np
from scipy.spatial import cKDTree
import matplotlib.pyplot as plt
from cartopy import crs as ccrs, feature as cfeature
import netCDF4 as nc
from scipy.interpolate import griddata
import seaborn as sns
from matplotlib.ticker import PercentFormatter
import matplotlib as mpl



smos_oct_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\SMOS\All years\SMOS_monthly\SMOS_monthly_Icethickness_north_202110.nc"
smos_nov_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\SMOS\All years\SMOS_monthly\SMOS_monthly_Icethickness_north_202111.nc"
smos_dec_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\SMOS\All years\SMOS_monthly\SMOS_monthly_Icethickness_north_202112.nc"

cpom_oct_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\CPOM product\thk_2021_10.map.nc"
cpom_nov_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\CPOM product\thk_2021_11.map.nc"
cpom_dec_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\CPOM product\thk_2021_12.map.nc"

cryo_oct_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\UiT product\uit_cryosat2_L3_EASE2_nh25km_2021_10_v3.nc"
cryo_nov_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\UiT product\uit_cryosat2_L3_EASE2_nh25km_2021_11_v3.nc"
cryo_dec_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\UiT product\uit_cryosat2_L3_EASE2_nh25km_2021_12_v3.nc"

awi_oct_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\AWI product\awi-siral-l3c-sithick-cryosat2-rep-nh_25km_ease2-202110-fv2p6.nc"
awi_nov_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\AWI product\awi-siral-l3c-sithick-cryosat2-rep-nh_25km_ease2-202111-fv2p6.nc"
awi_dec_2021 = r"C:\Users\trym7\OneDrive - UiT Office 365\skole\MASTER\Data processing\Data\CryoSat-2\AWI product\awi-siral-l3c-sithick-cryosat2-rep-nh_25km_ease2-202112-fv2p6.nc"



def get_cpom(path):
	data = nc.Dataset(path)
	#print("CPOM keys: ", data.variables.keys())
	
	lat = data.variables['latitude'][:]
	lon = data.variables['longitude'][:]
	si_thickness = data.variables['thickness'][:]
	si_thickness_un = data.variables['thk_stdev'][:]
	grid_spacing = data.variables["grid_spacing"][:]
	si_thickness_stdev = data.variables["thk_stdev"][:]
	
	#print(f"Lat shape: {lat.shape}")
	#print(f"Lon shape: {lon.shape}")
	#print(f"Thickness shape: {si_thickness.shape}")
	
	return lat, lon, si_thickness, si_thickness_un

def get_cryo(path):
	data = nc.Dataset(path)
	#print("cryo keys: ", data.variables.keys())
	
	lat = data.variables['latitude'][:]
	lon = data.variables['longitude'][:]
	si_thickness = data.variables['sea_ice_thickness'][:]
	si_thickness_un = data.variables['sea_ice_thickness_uncertainty'][:]
	
	# Check if lat and lon are 1D and need reshaping
	if lat.ndim == 1 and lon.ndim == 1:
		lon, lat = np.meshgrid(lon, lat)
		print('Reshaped lat and lon')
	# Mask invalid data
	mask = ~np.isnan(si_thickness)
	filtered_si_thickness = np.where(mask, si_thickness, np.nan)
	return lat, lon, filtered_si_thickness, si_thickness_un

def get_cryo_W99(path):
	data = nc.Dataset(path)
	
	lat = data.variables['latitude'][:]
	lon = data.variables['longitude'][:]
	si_thickness = data.variables['sea_ice_thickness_W99'][:]
	si_thickness_un = data.variables["sea_ice_thickness_uncertainty_W99"][:]
	
	if lat.ndim == 1 and lon.ndim == 1:
		lon, lat = np.meshgrid(lon, lat)
		print('Reshaped lat and lon')
	
	mask = ~np.isnan(si_thickness)
	filtered_si_thickness = np.where(mask, si_thickness, np.nan)
	return lat, lon, filtered_si_thickness, si_thickness_un

def get_smos(path):
	data = nc.Dataset(path)
	#print("smos keys: ", data.variables.keys())
	
	lat = data.variables['latitude'][:]
	lon = data.variables['longitude'][:]
	si_thickness = data.variables['mean_ice_thickness'][:]
	si_thickness_un = data.variables['uncertainty'][:]
	
	return lat, lon, si_thickness, si_thickness_un
	
def get_awi(path):
	data = nc.Dataset(path)
	#print("AWI keys: ", data.variables.keys())
	
	lat = data.variables['lat'][:]
	lon = data.variables['lon'][:]
	si_thickness = data.variables['sea_ice_thickness'][:]
	si_thickness_un = data.variables['sea_ice_thickness_uncertainty'][:]
	# Mask invalid data
	mask = ~np.isnan(si_thickness)
	filtered_si_thickness = np.where(mask, si_thickness, np.nan)

	return lat, lon, filtered_si_thickness, si_thickness_un


lat_awi_oct, lon_awi_oct, si_thickness_awi_oct, si_thickness_awi_oct_unc = get_awi(awi_oct_2021)
lat_awi_nov, lon_awi_nov, si_thickness_awi_nov, si_thickness_awi_nov_unc = get_awi(awi_nov_2021)
lat_awi_dec, lon_awi_dec, si_thickness_awi_dec, si_thickness_awi_dec_unc = get_awi(awi_dec_2021)

lat_cpom_oct, lon_cpom_oct, si_thickness_cpom_oct, si_thickness_cpom_oct_unc  = get_cpom(cpom_oct_2021)
lat_cpom_nov, lon_cpom_nov, si_thickness_cpom_nov, si_thickness_cpom_nov_unc = get_cpom(cpom_nov_2021)
lat_cpom_dec, lon_cpom_dec, si_thickness_cpom_dec, si_thicknees_cpom_dec_unc = get_cpom(cpom_dec_2021)

lat_cryo_oct, lon_cryo_oct, si_thickness_cryo_oct, si_thickness_cryo_oct_unc = get_cryo(cryo_oct_2021)
lat_cryo_nov, lon_cryo_nov, si_thickness_cryo_nov, si_thickness_cryo_nov_unc = get_cryo(cryo_nov_2021)
lat_cryo_dec, lon_cryo_dec, si_thickness_cryo_dec, si_thickness_cryo_dec_unc = get_cryo(cryo_dec_2021)

lat_w99_oct, lon_w99_oct, si_thickness_w99_oct, si_thickness_w99_oct_unc = get_cryo_W99(cryo_oct_2021)
lat_w99_nov, lon_w99_nov, si_thickness_w99_nov, si_thickness_w99_nov_unc = get_cryo_W99(cryo_nov_2021)
lat_w99_dec, lon_w99_dec, si_thickness_w99_dec, si_thickness_w99_dec_unc = get_cryo_W99(cryo_dec_2021)

lat_smos_oct, lon_smos_oct, si_thickness_smos_oct, si_thickness_smos_oct_unc = get_smos(smos_oct_2021)
lat_smos_nov, lon_smos_nov, si_thickness_smos_nov, si_thickness_smos_nov_unc = get_smos(smos_nov_2021)
lat_smos_dec, lon_smos_dec, si_thickness_smos_dec, si_thickness_smos_dec_unc = get_smos(smos_dec_2021)

def reprojecting(lon, lat, proj=ccrs.NorthPolarStereo()):
	""" 
	Reprojects geographical coordinates (longitude and latitude) to a specified map projection.
	
 	Parameters
	----------
	lon : array-like
		Array of longitude values in degrees.
	lat : array-like
		Array of latitude values in degrees.
	proj : cartopy.crs.Projection, optional
		The target map projection to which the coordinates will be reprojected.
		Defaults to `ccrs.NorthPolarStereo()`.
  
	Returns
	-------
	x : numpy.ndarray
		Array of x-coordinates in the target projection.
	y : numpy.ndarray
		Array of y-coordinates in the target projection.
  
	Notes
	-----
	This function uses the `transform_points` method from the `cartopy.crs` module
	to perform the reprojection. The input coordinates are assumed to be in the
	PlateCarree (geographical) projection.
	"""

	transformer = proj.transform_points(ccrs.PlateCarree(), lon, lat)
	x = transformer[..., 0]
	y = transformer[..., 1]
	return x, y

x_awi_oct, y_awi_oct = reprojecting(lon_awi_oct, lat_awi_oct)
x_awi_nov, y_awi_nov = reprojecting(lon_awi_nov, lat_awi_nov)
x_awi_dec, y_awi_dec = reprojecting(lon_awi_dec, lat_awi_dec)	

x_cpom_oct, y_cpom_oct = reprojecting(lon_cpom_oct, lat_cpom_oct)
x_cpom_nov, y_cpom_nov = reprojecting(lon_cpom_nov, lat_cpom_nov)
x_cpom_dec, y_cpom_dec = reprojecting(lon_cpom_dec, lat_cpom_dec)

x_cryo_oct, y_cryo_oct = reprojecting(lon_cryo_oct, lat_cryo_oct)
x_cryo_nov, y_cryo_nov = reprojecting(lon_cryo_nov, lat_cryo_nov)
x_cryo_dec, y_cryo_dec = reprojecting(lon_cryo_dec, lat_cryo_dec)

x_w99_oct, y_w99_oct = reprojecting(lon_w99_oct, lat_w99_oct)
x_w99_nov, y_w99_nov = reprojecting(lon_w99_nov, lat_w99_nov)
x_w99_dec, y_w99_dec = reprojecting(lon_w99_dec, lat_w99_dec)

x_smos_oct, y_smos_oct = reprojecting(lon_smos_oct, lat_smos_oct)
x_smos_nov, y_smos_nov = reprojecting(lon_smos_nov, lat_smos_nov)
x_smos_dec, y_smos_dec = reprojecting(lon_smos_dec, lat_smos_dec)

def resample_to_cryo_grid(x_source, y_source, source_sit, source_sit_un, x_target, y_target, radius=12500):
	"""
	Resample source data onto a target grid using weighted averaging.
	This function takes source data points with associated uncertainties and resamples
	them onto a target grid using a weighted averaging approach. The weights are 
	determined by the inverse of the uncertainties of the source data points.
 
	Parameters
	----------
	x_source : ndarray
		1D or 2D array of x-coordinates for the source data points.
	y_source : ndarray
		1D or 2D array of y-coordinates for the source data points.
	source_sit : ndarray
		1D or 2D array of source data values to be resampled.
	source_sit_un : ndarray
		1D or 2D array of uncertainties associated with the source data values.
	x_target : ndarray
		2D array of x-coordinates for the target grid.
	y_target : ndarray
		2D array of y-coordinates for the target grid.
	radius : float, optional
		Radius of influence for resampling, in the same units as the coordinates. 
		Default is 12500.
  
	Returns
	-------
	ndarray
		A 2D masked array containing the resampled data on the target grid. 
		Grid cells with no valid data points are masked.
  
	Notes
	-----
	- The function uses a KD-tree for efficient neighbor search within the specified radius.
	- If a source data point has an uncertainty of zero, its weight is set to zero to avoid
	  division by zero.
	- Grid cells with no valid data points are assigned NaN and masked in the output.
 
	Examples
	--------
	>>> import numpy as np
	>>> from scipy.spatial import cKDTree
	>>> x_source = np.array([0, 1, 2])
	>>> y_source = np.array([0, 1, 2])
	>>> source_sit = np.array([10, 20, 30])
	>>> source_sit_un = np.array([1, 2, 3])
	>>> x_target, y_target = np.meshgrid(np.linspace(0, 2, 3), np.linspace(0, 2, 3))
	>>> resampled = resample_to_cryo_grid(x_source, y_source, source_sit, source_sit_un, x_target, y_target)
	>>> print(resampled)
	[[10. 15. nan]
	 [nan 20. 25.]
	 [nan nan 30.]]
	"""
	
	target_tree = cKDTree(np.column_stack([x_target.ravel(), y_target.ravel()]))  # Tree for faster lookup

	# Initialize arrays to store resampled data and weight sums
	resampled_sit = np.full(x_target.shape, np.nan)
	weights_sum = np.zeros(x_target.shape)

	# Flatten all arrays for iteration
	source_sit = source_sit.ravel()
	source_sit_un = source_sit_un.ravel()
	x_source = x_source.ravel()
	y_source = y_source.ravel()

	for i in range(len(source_sit)):
		if np.isnan(source_sit[i]) or np.isnan(source_sit_un[i]):
			continue  # Skip invalid data points
		
		indices = target_tree.query_ball_point([x_source[i], y_source[i]], radius)

		if not indices:
			continue  # If no neighbors are found, skip

		weight = 1 / source_sit_un[i] if source_sit_un[i] != 0 else 0  # Avoid division by zero

		for idx in indices:
			if idx >= x_target.size:  # Ensure valid index
				continue
			
			row, col = np.unravel_index(idx, x_target.shape)

			# Avoid operations on uninitialized values
			if np.isnan(resampled_sit[row, col]):
				resampled_sit[row, col] = 0

			# Weighted sum calculation
			resampled_sit[row, col] = (resampled_sit[row, col] * weights_sum[row, col] + source_sit[i] * weight) / (weights_sum[row, col] + weight) 
			weights_sum[row, col] += weight

	# Mask invalid values (no data points found)
	resampled_sit[weights_sum == 0] = np.nan

	return np.ma.masked_invalid(resampled_sit)


cpom_resampled_sit_oct = resample_to_cryo_grid(x_cpom_oct, y_cpom_oct, si_thickness_cpom_oct, si_thickness_cpom_oct_unc, x_cryo_oct, y_cryo_oct)
awi_resampled_sit_oct = resample_to_cryo_grid(x_awi_oct, y_awi_oct, si_thickness_awi_oct, si_thickness_awi_oct_unc, x_cryo_oct, y_cryo_oct)
w99_resampled_sit_oct = resample_to_cryo_grid(x_w99_oct, y_w99_oct, si_thickness_w99_oct, si_thickness_w99_oct_unc, x_cryo_oct, y_cryo_oct)
smos_resampled_sit_oct = resample_to_cryo_grid(x_smos_oct, y_smos_oct, si_thickness_smos_oct, si_thickness_smos_oct_unc, x_cryo_oct, y_cryo_oct)

cpom_resampled_sit_nov = resample_to_cryo_grid(x_cpom_nov, y_cpom_nov, si_thickness_cpom_nov, si_thickness_cpom_nov_unc, x_cryo_nov, y_cryo_nov)
awi_resampled_sit_nov = resample_to_cryo_grid(x_awi_nov, y_awi_nov, si_thickness_awi_nov, si_thickness_awi_nov_unc, x_cryo_nov, y_cryo_nov)
w99_resampled_sit_nov = resample_to_cryo_grid(x_w99_nov, y_w99_nov, si_thickness_w99_nov, si_thickness_w99_nov_unc, x_cryo_nov, y_cryo_nov)
smos_resampled_sit_nov = resample_to_cryo_grid(x_smos_nov, y_smos_nov, si_thickness_smos_nov, si_thickness_smos_nov_unc, x_cryo_nov, y_cryo_nov)

cpom_resampled_sit_dec = resample_to_cryo_grid(x_cpom_dec, y_cpom_dec, si_thickness_cpom_dec, si_thicknees_cpom_dec_unc, x_cryo_dec, y_cryo_dec)
awi_resampled_sit_dec = resample_to_cryo_grid(x_awi_dec, y_awi_dec, si_thickness_awi_dec, si_thickness_awi_dec_unc, x_cryo_dec, y_cryo_dec)
w99_resampled_sit_dec = resample_to_cryo_grid(x_w99_dec, y_w99_dec, si_thickness_w99_dec, si_thickness_w99_dec_unc, x_cryo_dec, y_cryo_dec)
smos_resampled_sit_dec = resample_to_cryo_grid(x_smos_dec, y_smos_dec, si_thickness_smos_dec, si_thickness_smos_dec_unc, x_cryo_dec, y_cryo_dec)

 
def month_box_plot_scatter(cryo_interp, cpom_interp, awi_interp, smos_si):
	# For single months
	bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
	bin_labels = ['0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1']
	
	cryo_flat = cryo_interp.flatten()
	cpom_flat = cpom_interp.flatten()
	awi_flat = awi_interp.flatten()
	smos_flat = smos_si.flatten()
	
	# Mask out NaN values
	valid_mask = ~np.isnan(cryo_flat) & ~np.isnan(cpom_flat) & ~np.isnan(awi_flat) & ~np.isnan(smos_flat)
	cryo_flat = cryo_flat[valid_mask]
	cpom_flat = cpom_flat[valid_mask]
	awi_flat = awi_flat[valid_mask]
	smos_flat = smos_flat[valid_mask]
	
	# Bin the data
	binned_smos_cryo_data = []
	binned_smos_cpom_data = []
	binned_smos_awi_data = []
	
	for i in range(len(bins) - 1):
		mask = (smos_flat >= bins[i]) & (smos_flat < bins[i + 1])
		binned_smos_cryo_data.append(cryo_flat[mask])
		binned_smos_cpom_data.append(cpom_flat[mask])
		binned_smos_awi_data.append(awi_flat[mask])
  
	# Create subplots (1 row, 3 columns)
	fig, axes = plt.subplots(1, 3, sharey=True)

	# Plot boxplots in the respective axes
	axes[0].boxplot(binned_smos_cryo_data, labels=bin_labels, medianprops=dict(color='black'), facecolor='lightgray', alpha=0.5)
	axes[0].set_title("SMOS vs CryoSat-2")
	axes[0].set_xlabel("SMOS SIT [m]")
	axes[0].set_ylabel("CryoSat-2 SIT [m]")

	axes[1].boxplot(binned_smos_cpom_data, labels=bin_labels, medianprops=dict(color='black'), facecolor='lightgray', alpha=0.5)
	axes[1].set_title("SMOS vs CPOM")
	axes[1].set_xlabel("SMOS SIT [m]")
	axes[1].set_ylabel("CPOM SIT [m]")

	axes[2].boxplot(binned_smos_awi_data, labels=bin_labels, medianprops=dict(color='black'), facecolor='lightgray', alpha=0.5)
	axes[2].set_title("SMOS vs AWI")
	axes[2].set_xlabel("SMOS SIT [m]")
	axes[2].set_ylabel("AWI SIT [m]")

	for j in range(len(bins) - 1):
	 	# Jitter the x-position slightly for better visualization
		x_positions = np.random.normal(j + 1, 0.05, size=len(binned_smos_cryo_data[j]))
		axes[0].scatter(x_positions, binned_smos_cryo_data[j], alpha=0.4, color='salmon', s=10)
		
		x_positions = np.random.normal(j + 1, 0.05, size=len(binned_smos_cpom_data[j]))
		axes[1].scatter(x_positions, binned_smos_cpom_data[j], alpha=0.4, color='teal', s=10)
		
		x_positions = np.random.normal(j + 1, 0.05, size=len(binned_smos_awi_data[j]))
		axes[2].scatter(x_positions, binned_smos_awi_data[j], alpha=0.4, color='blueviolet', s=10)
 
	for ax in axes:
		ax.yaxis.set_tick_params(labelleft=True)
 
	# Adjust layout for better spacing
	plt.tight_layout()
	plt.show()
 
def multiple_box_plot_scatter_3x3(cryo_data, w99_data, awi_data, cpom_data, smos_data, month_names=['October', 'November', 'December']): # missing values on y axis
	bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
	bin_labels = ['0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1']

	fig, axes = plt.subplots(4, 3, figsize=(15, 10), sharex='col', sharey='row')

	products = ['UiT', "W99" ,'AWI', 'CPOM']
	colors = ['salmon', "skyblue", 'blueviolet', 'teal']
	all_data = [cryo_data, w99_data, awi_data, cpom_data]

	for row in range(4):  # Cryo, w99, AWI, CPOM
		for col in range(3):  # Oct, Nov, Dec
			product_data = all_data[row][col]
			smos_flat = smos_data[col].flatten()
			prod_flat = product_data.flatten()

			valid_mask = ~np.isnan(smos_flat) & ~np.isnan(prod_flat)
			smos_flat = smos_flat[valid_mask]
			prod_flat = prod_flat[valid_mask]

			binned_data = []
			medians = []

			for i in range(len(bins) - 1):
				mask = (smos_flat >= bins[i]) & (smos_flat < bins[i + 1])
				values = prod_flat[mask]
				binned_data.append(values)
				medians.append(np.nanmedian(values) if len(values) > 0 else np.nan)

			ax = axes[row, col]

			# Boxplot
			bp = ax.boxplot(
				binned_data,
				labels=bin_labels,
				medianprops=dict(color='black'),
				patch_artist=True
			)

			for patch in bp['boxes']:
				patch.set_facecolor('lightgray')
				patch.set_alpha(0.6)

			# Scatter
			for j, values in enumerate(binned_data):
				x = np.random.normal(j + 1, 0.05, size=len(values))
				ax.scatter(x, values, alpha=0.4, color=colors[row], s=10)

			# Formatting
			ax.set_ylim(-2.5, 7)

			if row == 0:
				ax.set_title(month_names[col])
			if row == 2:
				ax.set_xlabel("SMOS SIT [m]")
			else:
				ax.set_xticklabels([])  # Hide x-axis labels on top/middle rows

			if col == 0:
				ax.set_ylabel(f"{products[row]} SIT [m]")
			#else:
			#    ax.set_yticklabels([])  # Hide y-axis labels on non-left plots

			# Add legend inside the first plot of each row
			if col == 0:
				ax.legend([products[row]], loc='upper left', frameon=False)

	plt.tight_layout()
	plt.show()



 
def barplot(cryo_oct, cryo_nov, cryo_dec, w99_oct, w99_nov, w99_dec, cpom_oct, cpom_nov, cpom_dec, awi_oct, awi_nov, awi_dec, smos_oct, smos_nov, smos_dec):

	# Create figure and subplots
	fig, axs = plt.subplots(1, 3, figsize=(18, 5))
	months = ['October', 'November', 'December']

	# Datasets for each month
	datasets = [
		(cryo_oct, w99_oct, cpom_oct, awi_oct, smos_oct),
		(cryo_nov, w99_nov, cpom_nov, awi_nov, smos_nov),
		(cryo_dec, w99_dec, cpom_dec, awi_dec, smos_dec)
	]

	# Define bins: 0–0.2, 0.2–0.4, ..., 0.8–1.0
	bins = np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
	bin_centers = (bins[:-1] + bins[1:]) / 2
	bar_width = 0.03

	for i, (cryo, w99, cpom, awi, smos) in enumerate(datasets):
		# Flatten and filter NaNs
		cryo_flat = cryo.flatten()
		w99_flat = w99.flatten()
		cpom_flat = cpom.flatten()
		awi_flat = awi.flatten()
		smos_flat = smos.flatten()

		valid_mask = ~np.isnan(cryo_flat) & ~np.isnan(w99_flat) & \
					 ~np.isnan(cpom_flat) & ~np.isnan(awi_flat) & ~np.isnan(smos_flat)

		cryo_flat = cryo_flat[valid_mask]
		w99_flat = w99_flat[valid_mask]
		cpom_flat = cpom_flat[valid_mask]
		awi_flat = awi_flat[valid_mask]
		smos_flat = smos_flat[valid_mask]

		# Compute means
		mean_cryo, mean_w99, mean_cpom, mean_awi = [], [], [], []

		for j in range(len(bins) - 1):
			mask = (smos_flat >= bins[j]) & (smos_flat < bins[j + 1])
			mean_cryo.append(np.nanmean(cryo_flat[mask]) if np.any(mask) else np.nan)
			mean_w99.append(np.nanmean(w99_flat[mask]) if np.any(mask) else np.nan)
			mean_cpom.append(np.nanmean(cpom_flat[mask]) if np.any(mask) else np.nan)
			mean_awi.append(np.nanmean(awi_flat[mask]) if np.any(mask) else np.nan)

		# Plot
		ax = axs[i]
		ax.bar(bin_centers - bar_width, mean_cryo, width=bar_width, label='UiT', color='salmon')
		ax.bar(bin_centers, mean_w99, width=bar_width, label='W99', color='skyblue')
		ax.bar(bin_centers + bar_width, mean_awi, width=bar_width, label='AWI', color='blueviolet')
		ax.bar(bin_centers + 2 * bar_width, mean_cpom, width=bar_width, label='CPOM', color='teal')

		ax.set_title(f"{months[i]}")
		ax.set_xlabel("SMOS SIT [m]")
		ax.set_xlim(0, 1)
		ax.grid(axis='y', linestyle='--', alpha=0.5)

		if i == 0:
			ax.set_ylabel("Mean SIT [m]")
			ax.legend(loc='upper left', fontsize=9)

	plt.tight_layout()
	plt.show()
	

def histogram_2(cryo_oct, w99_oct, awi, cpom,smos_oct):
	""" 
	Only histogram for a specific month (October)
	"""
	# Flatten the data
	cryo_flat = cryo_oct.flatten()
	smos_flat = smos_oct.flatten()
	w99_flat = w99_oct.flatten()
	cpom_flat = cpom.flatten()
	awi_flat = awi.flatten()
 
	#mask = (smos_flat >= 0) & (smos_flat <= 1) & (cryo_flat >= 0) & (cryo_flat <= 1) & (w99_flat >= 0) & (w99_flat <= 1) & (cpom_flat >= 0) & (cpom_flat <= 1) & (awi_flat >= 0) & (awi_flat <= 1)
	mask = (smos_flat >= 0) & (smos_flat <= 1) 
	#mask1 = (smos_flat >= 0) & (smos_flat <= 1) & (cryo_flat >= 0) & (cryo_flat <= 1) & (w99_flat >= 0) & (w99_flat <= 1)
	#mask2 = (smos_flat >= 0) & (smos_flat <= 1) & (cpom_flat >= 0) & (cpom_flat <= 1) & (awi_flat >= 0) & (awi_flat <= 1)
 
	cryo_flat = cryo_flat[mask]
	smos_flat = smos_flat[mask]
	w99_flat = w99_flat[mask]
	cpom_flat = cpom_flat[mask]
	awi_flat = awi_flat[mask]
 
	mask_cryo = (cryo_flat >= 0) & (cryo_flat <= 1)
	mask_w99 = (w99_flat >= 0) & (w99_flat <= 1)
	mask_cpom = (cpom_flat >= 0) & (cpom_flat <= 1)
	mask_awi = (awi_flat >= 0) & (awi_flat <= 1)
 
	cryo_flat = cryo_flat[mask_cryo]
	w99_flat = w99_flat[mask_w99]
	cpom_flat = cpom_flat[mask_cpom]
	awi_flat = awi_flat[mask_awi]
 
 
	fig, ax = plt.subplots(1, 2, sharey=True)
	ax[0].hist(smos_flat, bins=20, color="navy", label="SMOS", zorder = 0)
	ax[0].hist(cryo_flat, bins=20, edgecolor="salmon", fill=True, color="salmon", hatch = "xx", label="CryoSat", alpha=0.5, zorder = 1)
	ax[0].hist(w99_flat, bins=20, edgecolor="skyblue", fill=False, hatch = "xx",label="W99", zorder = 2)
	ax[0].set_xlabel("Ice thickness [m]")
	ax[0].set_ylabel("Count")
	ax[0].legend()
	ax[0].grid(linestyle='--', alpha=0.5)
 
	ax[1].hist(smos_flat, bins=20, color="#155084", label="SMOS", zorder = 0)
	ax[1].hist(awi_flat, bins=20, edgecolor="blueviolet", fill=True,  color="blueviolet", hatch = "xx",label="AWI", alpha=0.5, zorder = 1)
	ax[1].hist(cpom_flat, bins=20, edgecolor="teal", fill=False, hatch = "xx",label="CPOM", zorder = 2)
	ax[1].set_xlabel("Ice thickness [m]")
	ax[1].legend()
	ax[1].grid(linestyle='--', alpha=0.5)	

	plt.yscale('log')
	plt.tight_layout()
	plt.show()
 

def bar_with_histograms(
	cryo_oct, cryo_nov, cryo_dec,
	w99_oct,  w99_nov,  w99_dec,
	cpom_oct, cpom_nov, cpom_dec,
	awi_oct,  awi_nov,  awi_dec,
	smos_oct, smos_nov, smos_dec,
	bin_edges=np.linspace(0,1,21),
	bar_bins=np.array([0,0.2,0.4,0.6,0.8,1.0]),
	bar_width=0.03
):
	months = ['October','November','December']
	datasets = [
		(cryo_oct, w99_oct, cpom_oct, awi_oct, smos_oct),
		(cryo_nov, w99_nov, cpom_nov, awi_nov, smos_nov),
		(cryo_dec, w99_dec, cpom_dec, awi_dec, smos_dec),
	]

	fig = plt.figure(figsize=(18,10))
	# outer grid: 2 rows (bars, hists), 3 columns (months)
	outer = fig.add_gridspec(2, 3, height_ratios=[2,1], hspace=0.2, wspace=0.15) # hspace defines space between rows, wspace between columns for 

	# --- Top row: bar plots ---
	bar_axes = [fig.add_subplot(outer[0, i]) for i in range(3)]

	# --- Bottom row: for each month, carve out a 1×2 sub-grid for two histograms side by side ---
	hist_axes = []
	for i in range(3):
		sub = outer[1, i].subgridspec(1, 2, wspace=0.3)
		ax_left  = fig.add_subplot(sub[0,0])
		ax_right = fig.add_subplot(sub[0,1])
		hist_axes.append((ax_left, ax_right))

	# Now loop over months to fill in the axes
	for i, (cryo, w99, cpom, awi, smos) in enumerate(datasets):
		# flatten & mask NaNs
		cryo_f = cryo.ravel();  w99_f = w99.ravel()
		cpom_f = cpom.ravel();  awi_f = awi.ravel()
		smos_f = smos.ravel()
		valid = ~np.isnan(cryo_f)&~np.isnan(w99_f)&~np.isnan(cpom_f)&~np.isnan(awi_f)&~np.isnan(smos_f)
		cryo_f, w99_f, cpom_f, awi_f, smos_f = [arr[valid] for arr in (cryo_f,w99_f,cpom_f,awi_f,smos_f)]

		# ---- 1) BARPLOT ----
		means = {'UiT':[], 'W99':[], 'AWI':[], 'CPOM':[]}
		for lo, hi in zip(bar_bins[:-1], bar_bins[1:]):
			m = (smos_f>=lo)&(smos_f<hi)
			means['UiT'].append(np.nanmean(cryo_f[m]) if m.any() else np.nan)
			means['W99'].append(np.nanmean(w99_f[m])   if m.any() else np.nan)
			means['AWI'].append(np.nanmean(awi_f[m])   if m.any() else np.nan)
			means['CPOM'].append(np.nanmean(cpom_f[m]) if m.any() else np.nan)

		bc = (bar_bins[:-1] + bar_bins[1:]) / 2
		ax = bar_axes[i]
		ax.bar(bc-bar_width,   means['UiT'],  bar_width, color='salmon',     label='UiT')
		ax.bar(bc,             means['W99'],  bar_width, color='skyblue',   label='W99')
		ax.bar(bc+bar_width,   means['AWI'],  bar_width, color='blueviolet',label='AWI')
		ax.bar(bc+2*bar_width, means['CPOM'], bar_width, color='teal',      label='CPOM')
		ax.set_title(months[i])
		ax.set_xlim(0,1)
		ax.set_xlabel('SMOS SIT [m]')
		if i == 0:
			ax.set_ylabel('Mean SIT [m]')
			ax.legend(fontsize=9)
		ax.grid(axis='y', linestyle='--', alpha=0.5)

		# ---- 2) Prepare mask for histograms (SMOS between 0–1 m) ----
		m0   = (smos_f>=0)&(smos_f<=1)
		smos_m, cryo_m, w99_m = smos_f[m0], cryo_f[m0], w99_f[m0]
		awi_m, cpom_m  = awi_f[m0],  cpom_f[m0]

		# ---- 3) Left histogram (SMOS vs Cryo & W99) ----
		axL, axR = hist_axes[i]
		axL.hist(smos_m, bins=bin_edges, color='#155084', zorder=0, label='SMOS')
		axL.hist(cryo_m, bins=bin_edges, edgecolor='salmon', linewidth=1, fill=True, color='salmon', alpha=0.5, hatch='xx', zorder=1, label='UiT')
		axL.hist(w99_m,  bins=bin_edges, edgecolor='skyblue', fill=False, hatch='xx', zorder=2, label='W99')
		if i == 0:
			axL.legend(fontsize=8)
		axL.set_xlabel('SIT [m]')
		if i == 0:
			axL.set_ylabel('Count')
		axL.grid(linestyle='--')
		axL.set_yscale('log')

		# ---- 4) Right histogram (SMOS vs AWI & CPOM) ----
		axR.hist(smos_m, bins=bin_edges, color='#155084', zorder=0, label='SMOS')
		axR.hist(awi_m,  bins=bin_edges, edgecolor='blueviolet', linewidth=1, fill=True, color = 'blueviolet' , alpha=0.5, hatch='xx', zorder=1, label='AWI')
		axR.hist(cpom_m, bins=bin_edges, edgecolor='teal', fill=False, hatch='xx', zorder=2, label='CPOM')
		axR.set_xlabel('SIT [m]')
		axR.grid(linestyle='--')
		if i == 0:
			axR.legend(fontsize=8)

		# log‐scale y for both small histograms
		axL.set_yscale('log')
		axR.set_yscale('log')

	plt.tight_layout()
	plt.show()

def heatmap_sea_ice_difference(cryo_interp, w99_interp, cpom_interp, awi_interp, smos_si, month):
	#single month
	bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
	bin_labels = ['0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1']
	satellite_products = ["UiT", "W99", "CPOM", "AWI"]
	
	cryo_flat = cryo_interp.flatten()
	w99_flat = w99_interp.flatten()
	cpom_flat = cpom_interp.flatten()
	awi_flat = awi_interp.flatten()
	smos_flat = smos_si.flatten()

	# Mask out NaN values
	valid_mask = ~np.isnan(cryo_flat) & ~np.isnan(cpom_flat) & ~np.isnan(awi_flat) & ~np.isnan(smos_flat)
	cryo_flat = cryo_flat[valid_mask]
	w99_flat = w99_flat[valid_mask]
	cpom_flat = cpom_flat[valid_mask]
	awi_flat = awi_flat[valid_mask]
	smos_flat = smos_flat[valid_mask]

	# Initialize array to store mean differences
	mean_differences = np.zeros((len(satellite_products), len(bins) - 1))

	# Compute mean differences for each bin
	for i in range(len(bins) - 1):
		mask = (smos_flat >= bins[i]) & (smos_flat < bins[i + 1])
		
		if np.any(mask):  # Ensure there is data in the bin
			mean_differences[0, i] = np.nanmean(cryo_flat[mask] - smos_flat[mask])  # CryoSat-2 - SMOS
			mean_differences[1, i] = np.nanmean(w99_flat[mask] - smos_flat[mask])   # W99 - SMOS
			mean_differences[2, i] = np.nanmean(cpom_flat[mask] - smos_flat[mask])  # CPOM - SMOS
			mean_differences[3, i] = np.nanmean(awi_flat[mask] - smos_flat[mask])   # AWI - SMOS
		else:
			mean_differences[:, i] = np.nan  # Assign NaN if no valid data

	# Create the heatmap
	plt.figure(figsize=(8, 6))
	ax = sns.heatmap(mean_differences, annot=True, cmap="plasma", fmt=".2f",
					 xticklabels=bin_labels, yticklabels=satellite_products, center=0)

	plt.xlabel("SMOS SIT Bins [m]")
	plt.ylabel("CryoSat-2 Products")
	plt.title(f"Mean Difference in SIT (Cryosat2 - SMOS), {month}")
	plt.show()


def heatmap_sea_ice_difference_3months(
	cryo_list, w99_list, cpom_list, awi_list, smos_list,
	month_names=["October", "November", "December"]
):
	bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
	bin_labels = ['0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1']
	satellite_products = ["UiT", "W99", "CPOM", "AWI"]

	fig, axes = plt.subplots(1, 3, figsize=(18, 6), sharey=True)

	for idx, ax in enumerate(axes):
		cryo_flat = cryo_list[idx].flatten()
		w99_flat = w99_list[idx].flatten()
		cpom_flat = cpom_list[idx].flatten()
		awi_flat = awi_list[idx].flatten()
		smos_flat = smos_list[idx].flatten()

		valid_mask = (
			~np.isnan(cryo_flat) & ~np.isnan(w99_flat) &
			~np.isnan(cpom_flat) & ~np.isnan(awi_flat) & ~np.isnan(smos_flat)
		)
		cryo_flat = cryo_flat[valid_mask]
		w99_flat = w99_flat[valid_mask]
		cpom_flat = cpom_flat[valid_mask]
		awi_flat = awi_flat[valid_mask]
		smos_flat = smos_flat[valid_mask]

		mean_differences = np.full((len(satellite_products), len(bins) - 1), np.nan)

		for i in range(len(bins) - 1):
			mask = (smos_flat >= bins[i]) & (smos_flat < bins[i + 1])
			if np.any(mask):
				mean_differences[0, i] = np.nanmean(cryo_flat[mask] - smos_flat[mask])
				mean_differences[1, i] = np.nanmean(w99_flat[mask] - smos_flat[mask])
				mean_differences[2, i] = np.nanmean(cpom_flat[mask] - smos_flat[mask])
				mean_differences[3, i] = np.nanmean(awi_flat[mask] - smos_flat[mask])

		sns.heatmap(
			mean_differences,
			annot=True,
			cmap="plasma",
			fmt=".2f",
			xticklabels=bin_labels,
			yticklabels=satellite_products,  # Show labels in every subplot
			center=0,
			ax=ax,
			cbar=(idx == 2),
			cbar_kws={"label": "Mean Difference (m)"}
		)

		ax.set_title(month_names[idx])
		ax.set_xlabel("SMOS SIT Bins [m]")

	plt.tight_layout()
	plt.show()

def average_difference_target_source(cryo_interp, cpom_interp, awi_interp, smos_si):
	# Define bins and labels
	bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
	bin_labels = ['0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1']
	
	# Flatten arrays
	cryo_flat = cryo_interp.flatten()
	cpom_flat = cpom_interp.flatten()
	awi_flat = awi_interp.flatten()
	smos_flat = smos_si.flatten()
	
	# Remove NaN values
	valid_mask = ~np.isnan(cryo_flat) & ~np.isnan(cpom_flat) & ~np.isnan(awi_flat) & ~np.isnan(smos_flat)
	cryo_flat = cryo_flat[valid_mask]
	cpom_flat = cpom_flat[valid_mask]
	awi_flat = awi_flat[valid_mask]
	smos_flat = smos_flat[valid_mask]

	# Initialize lists to store results
	mean_differences_cryo = []
	mean_differences_cpom = []
	mean_differences_awi = []
	
	corr_cryo = []
	corr_cpom = []
	corr_awi = []

	rmse_cryo = []
	rmse_cpom = []
	rmse_awi = []
 
	# Compute mean difference for each bin
	for i in range(len(bins) - 1):
		mask = (smos_flat >= bins[i]) & (smos_flat < bins[i + 1])
		
		if np.any(mask):  # Check if the bin contains any values
			smos_bin = smos_flat[mask]
			cryo_bin = cryo_flat[mask]
			cpom_bin = cpom_flat[mask]
			awi_bin = awi_flat[mask]

			
			smos_mean = np.mean(smos_flat[mask])  # Mean SMOS value in the bin
			
			# Compute mean differences
			mean_differences_cryo.append(np.mean(cryo_flat[mask]) - smos_mean)
			mean_differences_cpom.append(np.mean(cpom_flat[mask]) - smos_mean)
			mean_differences_awi.append(np.mean(awi_flat[mask]) - smos_mean)
			
			corr_cryo.append(np.corrcoef(smos_bin, cryo_bin)[0, 1])
			corr_cpom.append(np.corrcoef(smos_bin, cpom_bin)[0, 1])
			corr_awi.append(np.corrcoef(smos_bin, awi_bin)[0, 1])
   
			rmse_cryo.append(np.sqrt(np.mean((cryo_flat[mask] - smos_bin) ** 2)))
			rmse_cpom.append(np.sqrt(np.mean((cpom_flat[mask] - smos_bin) ** 2)))
			rmse_awi.append(np.sqrt(np.mean((awi_flat[mask] - smos_bin) ** 2)))   
		else:
			# Append NaN if no values in bin to keep dimensions consistent
			mean_differences_cryo.append(np.nan)
			mean_differences_cpom.append(np.nan)
			mean_differences_awi.append(np.nan)
	
	# print results
	print("-----------------SMOS and UiT-----------------")
	print(f"Mean difference: {np.round(mean_differences_cryo, 3)}")
	print(f"Correlation coefficient: {np.round(corr_cryo, 3)}") 
	print(f"RMSE: {np.round(rmse_cryo, 3)}")
	print("Total mean difference: ", np.round(np.nanmean(mean_differences_cryo), 3))
	print("Total RMSE:", np.round(np.nanmean(rmse_cryo), 3))
	print("\n-----------------SMOS and CPOM-----------------")
	print(f"Mean difference: {np.round(mean_differences_cpom, 3)}")
	print(f"Correlation coefficient: {np.round(corr_cpom, 3)}")
	print(f"RMSE: {np.round(rmse_cpom, 3)}")
	print("Total mean difference: ", np.round(np.nanmean(mean_differences_cpom), 3))
	print("Total RMSE:", np.round(np.nanmean(rmse_cpom), 3))
	print("\n-----------------SMOS and AWI-----------------")
	print(f"Mean difference: {np.round(mean_differences_awi, 3)}")
	print(f"Correlation coefficient: {np.round(corr_awi, 3)}")
	print(f"RMSE: {np.round(rmse_awi, 3)}")
	print("Total mean difference: ", np.round(np.nanmean(mean_differences_awi), 3))
	print("Total RMSE:", np.round(np.nanmean(rmse_awi), 3))



def map_difference(cryo_interp, smos_interp, lat_smos, lon_smos, month_label=str):
	""" 
	The function plots the main difference at every grid point between the CryoSat-2 and SMOS sea ice thickness data,
	from 0 - 1 m, with the colorbar representing the difference in meters. In polar stereographic projection.
	"""
	# Check the shape of the inputs
	print(f"Shape of CryoSat-2 data: {cryo_interp.shape}")
	print(f"Shape of SMOS data: {smos_interp.shape}")
	print(f"Shape of lat_smos: {lat_smos.shape}")
	print(f"Shape of lon_smos: {lon_smos.shape}")

	# If the difference is 3D, choose the appropriate time step (e.g., for November)
	if len(cryo_interp.shape) == 3:  # Check if the data is 3D (time, lat, lon)
		# Choose a specific time step (e.g., taking the first time step for CryoSat and SMOS)
		cryo_interp = cryo_interp[0, :, :]  # First time step for CryoSat-2
		smos_interp = smos_interp[0, :, :]  # First time step for SMOS data

	# Compute the difference between CryoSat-2 and SMOS SIT data
	difference = cryo_interp - smos_interp
	
	difference[smos_interp > 1] = np.nan  # Mask out SMOS SIT values greater than 1 m
	
	# Remove the extra dimension (squeeze to make it 2D)
	difference = np.squeeze(difference)
	
	# Check the shape of the difference array to make sure it's 2D
	print(f"Shape of the difference after squeezing: {difference.shape}")
	
	# Create the figure and axis for the map with Polar Stereographic projection
	fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={'projection': ccrs.NorthPolarStereo()})
	
	# Set up the map features: coastlines, gridlines, etc.
	ax.set_extent([-3e6, 3e6, -3e6, 3e6], crs=ccrs.NorthPolarStereo()) # Set the region to the Arctic
	ax.add_feature(cfeature.LAND, color='lightgray', alpha=1, zorder=2)
	ax.add_feature(cfeature.LAKES, edgecolor='gray', facecolor="white", linewidth=0.5, alpha=0.5, zorder=3)
	ax.add_feature(cfeature.COASTLINE, color = "gray", linewidth=0.5, zorder=4)
	
	# Plot the difference data on the map
	# Ensure lat_smos and lon_smos are 2D, and difference is 2D
	im = ax.pcolormesh(lon_smos, lat_smos, difference, transform=ccrs.PlateCarree(), cmap='coolwarm', shading='auto')

	# Add a colorbar to represent the difference in meters
	cbar = plt.colorbar(im, ax=ax, orientation='vertical', pad=0.01, fraction=0.02)
	cbar.set_label("Difference in SIT (m)", fontsize=12)

	# Set the title
	ax.set_title(f'Difference between CryoSat-2 and SMOS SIT, {month_label}', fontsize=14)

	# Show the plot
	plt.show()
	
 
if __name__ == '__main__':
	#multiple_box_plot_scatter(cryo_interp, cpom_interp, awi_interp, si_thickness_smos_dec)
	#multiple_box_plot_scatter_3x3(
	#cryo_data=[si_thickness_cryo_oct, si_thickness_cryo_nov, si_thickness_cryo_dec],
	#awi_data=[awi_resampled_sit_oct, awi_resampled_sit_nov, awi_resampled_sit_dec],
	#cpom_data=[cpom_resampled_sit_oct, cpom_resampled_sit_nov, cpom_resampled_sit_dec],
	#smos_data=[smos_resampled_sit_oct, smos_resampled_sit_nov, smos_resampled_sit_dec],
	#)
 
 
	#barplot(
	#si_thickness_cryo_oct, si_thickness_cryo_nov, si_thickness_cryo_dec, 
	#w99_resampled_sit_oct, w99_resampled_sit_nov, w99_resampled_sit_dec, 
	#cpom_resampled_sit_oct, cpom_resampled_sit_nov, cpom_resampled_sit_dec, 
	#awi_resampled_sit_oct, awi_resampled_sit_nov, awi_resampled_sit_dec, 
	#smos_resampled_sit_oct, smos_resampled_sit_nov, smos_resampled_sit_dec
	#)
	#histogram(si_thickness_cryo_oct, si_thickness_cryo_nov, si_thickness_cryo_dec,
	#w99_resampled_sit_oct,  w99_resampled_sit_nov,  w99_resampled_sit_dec,
	#cpom_resampled_sit_oct, cpom_resampled_sit_nov, cpom_resampled_sit_dec,
	#awi_resampled_sit_oct,  awi_resampled_sit_nov,  awi_resampled_sit_dec,
	#smos_resampled_sit_oct, smos_resampled_sit_nov, smos_resampled_sit_dec,
	#bins=30)
	#histogram_2(si_thickness_cryo_oct, w99_resampled_sit_oct, awi_resampled_sit_oct, cpom_resampled_sit_oct, smos_resampled_sit_oct)
	bar_with_histograms(
	si_thickness_cryo_oct, si_thickness_cryo_nov, si_thickness_cryo_dec,
	w99_resampled_sit_oct,  w99_resampled_sit_nov,  w99_resampled_sit_dec,
	cpom_resampled_sit_oct, cpom_resampled_sit_nov, cpom_resampled_sit_dec,
	awi_resampled_sit_oct,  awi_resampled_sit_nov,  awi_resampled_sit_dec,
	smos_resampled_sit_oct, smos_resampled_sit_nov, smos_resampled_sit_dec,
	)
 
	#heatmap_sea_ice_difference(si_thickness_cryo_oct, w99_resampled_sit_oct, cpom_resampled_sit_oct, awi_resampled_sit_oct, smos_resampled_sit_oct, "October")
	#heatmap_sea_ice_difference_3months(
	#[si_thickness_cryo_oct, si_thickness_cryo_nov, si_thickness_cryo_dec],
	#[w99_resampled_sit_oct, w99_resampled_sit_nov, w99_resampled_sit_dec],
	#[cpom_resampled_sit_oct, cpom_resampled_sit_nov, cpom_resampled_sit_dec],
	#[awi_resampled_sit_oct, awi_resampled_sit_nov, awi_resampled_sit_dec],
	#[smos_resampled_sit_oct, smos_resampled_sit_nov, smos_resampled_sit_dec],
	#)
 
	#map_difference(cryo_interp_oct, si_thickness_smos_oct, lat_smos_dec, lon_smos_dec, "December")
	#histogram(cryo_interp_oct, si_thickness_smos_oct)
 
	#average_difference_target_source(si_thickness_cryo_oct, cpom_resampled_sit_oct, awi_resampled_sit_oct, smos_resampled_sit_oct)